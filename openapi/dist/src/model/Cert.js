/**
 * Hardenize Org API
 * Hardenize is a platform for continuous monitoring of network and security configuration. Hardenize supports individual accounts, intended for use by a single person, and organization accounts, which are shared among potentially many individuals. Whereas individual accounts are limited, organization accounts can have access to all Hardenize features. The Organization API, documented here, provides ability to manage and retrieve information from organization accounts.  At this time, because we're still developing these APIs, they are not enabled by default for all organizations. Please contact us so that we can enable the APIs for you. After that you'll be able to generate your API credentials in the Settings section.  **This specification is a work in progress and may change without notice.** 
 *
 * OpenAPI spec version: 0.1.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 *
 * OpenAPI Generator version: 3.2.1
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/CertCtLog', 'model/DateTime'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('./CertCtLog'), require('./DateTime'));
  } else {
    // Browser globals (root is window)
    if (!root.HardenizeOrgApi) {
      root.HardenizeOrgApi = {};
    }
    root.HardenizeOrgApi.Cert = factory(root.HardenizeOrgApi.ApiClient, root.HardenizeOrgApi.CertCtLog, root.HardenizeOrgApi.DateTime);
  }
}(this, function(ApiClient, CertCtLog, DateTime) {
  'use strict';




  /**
   * The Cert model module.
   * @module model/Cert
   * @version 0.1.1
   */

  /**
   * Constructs a new <code>Cert</code>.
   * @alias module:model/Cert
   * @class
   * @param sha256 {String} Hex-encoded SHA256 hash of the certificate in DER format
   * @param subject {String} Subject distinguished name
   * @param serial {String} Hex-encoded serial number
   * @param issuer {String} Issuer distinguished name
   * @param notBefore {module:model/Date} ISO 8601 timestamp
   * @param notAfter {module:model/Date} ISO 8601 timestamp
   * @param effectiveNotAfter {module:model/Date} ISO 8601 timestamp. This fields contains the time after which the certificate cannot be used in practice. For example, certificates issued from the old Symantec PKI infrastructure have been deprecated and can no longer be used for web sites, even though they are still technically valid. Depending on the deprecation phase, Symantec certificates will have the effective dates of March 1, 2018 (phase one) or September 1, 2018 (phase 2). 
   * @param revokedOn {module:model/Date} Revocation timestamp, if available.
   * @param hosts {Array.<String>} All hosts specified in the certificate's SAN extension. This list includes both hosts and IP addresses. Wildcard hostnames are denoted with a leading dot, but no asterisk. 
   * @param firstSeen {module:model/Date} The first time this certificate was seen, which could be a variety of sources for example, CT, manual upload, or installed on a server. 
   * @param lastSeen {module:model/Date} The last time this certificate was seen installed on a server
   * @param precert {Boolean} Indicates if the returned certificate is, in fact, a precertificate.
   * @param pem {String} Base64-encoded certificate in DER format
   */
  var exports = function(sha256, subject, serial, issuer, notBefore, notAfter, effectiveNotAfter, revokedOn, hosts, firstSeen, lastSeen, precert, pem) {
    var _this = this;

    _this['sha256'] = sha256;
    _this['subject'] = subject;
    _this['serial'] = serial;
    _this['issuer'] = issuer;
    _this['notBefore'] = notBefore;
    _this['notAfter'] = notAfter;
    _this['effectiveNotAfter'] = effectiveNotAfter;
    _this['revokedOn'] = revokedOn;





    _this['hosts'] = hosts;



    _this['firstSeen'] = firstSeen;
    _this['lastSeen'] = lastSeen;

    _this['precert'] = precert;







    _this['pem'] = pem;
  };

  /**
   * Constructs a <code>Cert</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Cert} obj Optional instance to populate.
   * @return {module:model/Cert} The populated <code>Cert</code> instance.
   */
  exports.constructFromObject = function(data, obj) {
    if (data) {
      obj = obj || new exports();

      if (data.hasOwnProperty('sha256')) {
        obj['sha256'] = ApiClient.convertToType(data['sha256'], 'String');
      }
      if (data.hasOwnProperty('subject')) {
        obj['subject'] = ApiClient.convertToType(data['subject'], 'String');
      }
      if (data.hasOwnProperty('serial')) {
        obj['serial'] = ApiClient.convertToType(data['serial'], 'String');
      }
      if (data.hasOwnProperty('issuer')) {
        obj['issuer'] = ApiClient.convertToType(data['issuer'], 'String');
      }
      if (data.hasOwnProperty('notBefore')) {
        obj['notBefore'] = ApiClient.convertToType(data['notBefore'], 'Date');
      }
      if (data.hasOwnProperty('notAfter')) {
        obj['notAfter'] = ApiClient.convertToType(data['notAfter'], 'Date');
      }
      if (data.hasOwnProperty('effectiveNotAfter')) {
        obj['effectiveNotAfter'] = ApiClient.convertToType(data['effectiveNotAfter'], 'Date');
      }
      if (data.hasOwnProperty('revokedOn')) {
        obj['revokedOn'] = ApiClient.convertToType(data['revokedOn'], 'Date');
      }
      if (data.hasOwnProperty('keyAlg')) {
        obj['keyAlg'] = ApiClient.convertToType(data['keyAlg'], 'String');
      }
      if (data.hasOwnProperty('keyLen')) {
        obj['keyLen'] = ApiClient.convertToType(data['keyLen'], 'Number');
      }
      if (data.hasOwnProperty('keyStrength')) {
        obj['keyStrength'] = ApiClient.convertToType(data['keyStrength'], 'Number');
      }
      if (data.hasOwnProperty('sigAlg')) {
        obj['sigAlg'] = ApiClient.convertToType(data['sigAlg'], 'String');
      }
      if (data.hasOwnProperty('spkiSha256')) {
        obj['spkiSha256'] = ApiClient.convertToType(data['spkiSha256'], 'String');
      }
      if (data.hasOwnProperty('hosts')) {
        obj['hosts'] = ApiClient.convertToType(data['hosts'], ['String']);
      }
      if (data.hasOwnProperty('caPathLen')) {
        obj['caPathLen'] = ApiClient.convertToType(data['caPathLen'], 'Number');
      }
      if (data.hasOwnProperty('wildcard')) {
        obj['wildcard'] = ApiClient.convertToType(data['wildcard'], 'Boolean');
      }
      if (data.hasOwnProperty('selfSigned')) {
        obj['selfSigned'] = ApiClient.convertToType(data['selfSigned'], 'Boolean');
      }
      if (data.hasOwnProperty('firstSeen')) {
        obj['firstSeen'] = ApiClient.convertToType(data['firstSeen'], 'Date');
      }
      if (data.hasOwnProperty('lastSeen')) {
        obj['lastSeen'] = ApiClient.convertToType(data['lastSeen'], 'Date');
      }
      if (data.hasOwnProperty('seenInstalled')) {
        obj['seenInstalled'] = ApiClient.convertToType(data['seenInstalled'], 'Boolean');
      }
      if (data.hasOwnProperty('precert')) {
        obj['precert'] = ApiClient.convertToType(data['precert'], 'Boolean');
      }
      if (data.hasOwnProperty('managed')) {
        obj['managed'] = ApiClient.convertToType(data['managed'], 'Boolean');
      }
      if (data.hasOwnProperty('ownership')) {
        obj['ownership'] = ApiClient.convertToType(data['ownership'], 'String');
      }
      if (data.hasOwnProperty('matchesOrgHost')) {
        obj['matchesOrgHost'] = ApiClient.convertToType(data['matchesOrgHost'], 'Boolean');
      }
      if (data.hasOwnProperty('symantecStatus')) {
        obj['symantecStatus'] = ApiClient.convertToType(data['symantecStatus'], 'String');
      }
      if (data.hasOwnProperty('ctRequired')) {
        obj['ctRequired'] = ApiClient.convertToType(data['ctRequired'], 'Boolean');
      }
      if (data.hasOwnProperty('ctCompliant')) {
        obj['ctCompliant'] = ApiClient.convertToType(data['ctCompliant'], 'Boolean');
      }
      if (data.hasOwnProperty('ctLogs')) {
        obj['ctLogs'] = ApiClient.convertToType(data['ctLogs'], [CertCtLog]);
      }
      if (data.hasOwnProperty('pem')) {
        obj['pem'] = ApiClient.convertToType(data['pem'], 'String');
      }
    }
    return obj;
  }

  /**
   * Hex-encoded SHA256 hash of the certificate in DER format
   * @member {String} sha256
   */
  exports.prototype['sha256'] = undefined;
  /**
   * Subject distinguished name
   * @member {String} subject
   */
  exports.prototype['subject'] = undefined;
  /**
   * Hex-encoded serial number
   * @member {String} serial
   */
  exports.prototype['serial'] = undefined;
  /**
   * Issuer distinguished name
   * @member {String} issuer
   */
  exports.prototype['issuer'] = undefined;
  /**
   * ISO 8601 timestamp
   * @member {module:model/Date} notBefore
   */
  exports.prototype['notBefore'] = undefined;
  /**
   * ISO 8601 timestamp
   * @member {module:model/Date} notAfter
   */
  exports.prototype['notAfter'] = undefined;
  /**
   * ISO 8601 timestamp. This fields contains the time after which the certificate cannot be used in practice. For example, certificates issued from the old Symantec PKI infrastructure have been deprecated and can no longer be used for web sites, even though they are still technically valid. Depending on the deprecation phase, Symantec certificates will have the effective dates of March 1, 2018 (phase one) or September 1, 2018 (phase 2). 
   * @member {module:model/Date} effectiveNotAfter
   */
  exports.prototype['effectiveNotAfter'] = undefined;
  /**
   * Revocation timestamp, if available.
   * @member {module:model/Date} revokedOn
   */
  exports.prototype['revokedOn'] = undefined;
  /**
   * Private key algorithm, for example RSA or EC.
   * @member {String} keyAlg
   */
  exports.prototype['keyAlg'] = undefined;
  /**
   * Private key length, for example 256 for an ECDSA key or 2048 for an RSA key.
   * @member {Number} keyLen
   */
  exports.prototype['keyLen'] = undefined;
  /**
   * Estimated private key strength in symmetric bits. For example, a 256-bit ECDSA key is thought to provide 128 bits of security, whereas a 2048-bit RSA key provides about 112. 
   * @member {Number} keyStrength
   */
  exports.prototype['keyStrength'] = undefined;
  /**
   * Certificate signature algorithm.
   * @member {module:model/Cert.SigAlgEnum} sigAlg
   */
  exports.prototype['sigAlg'] = undefined;
  /**
   * Hex-encoded SHA256 of the certificate's SPKI component
   * @member {String} spkiSha256
   */
  exports.prototype['spkiSha256'] = undefined;
  /**
   * All hosts specified in the certificate's SAN extension. This list includes both hosts and IP addresses. Wildcard hostnames are denoted with a leading dot, but no asterisk. 
   * @member {Array.<String>} hosts
   */
  exports.prototype['hosts'] = undefined;
  /**
   * Indicates if this is a CA certificate. Leaf certificates will have -1 in this field, indicating that they cannot issue further certificates. CA certificates will have 0 or a positive number. CA certificates without path length limit will have 2,147,483,647. 
   * @member {Number} caPathLen
   */
  exports.prototype['caPathLen'] = undefined;
  /**
   * Set to true if the hostname list contains at least one wildcard.
   * @member {Boolean} wildcard
   */
  exports.prototype['wildcard'] = undefined;
  /**
   * Set to true if this is a self-signed certificate.
   * @member {Boolean} selfSigned
   */
  exports.prototype['selfSigned'] = undefined;
  /**
   * The first time this certificate was seen, which could be a variety of sources for example, CT, manual upload, or installed on a server. 
   * @member {module:model/Date} firstSeen
   */
  exports.prototype['firstSeen'] = undefined;
  /**
   * The last time this certificate was seen installed on a server
   * @member {module:model/Date} lastSeen
   */
  exports.prototype['lastSeen'] = undefined;
  /**
   * Indicates if this certificate has been seen installed on a server
   * @member {Boolean} seenInstalled
   */
  exports.prototype['seenInstalled'] = undefined;
  /**
   * Indicates if the returned certificate is, in fact, a precertificate.
   * @member {Boolean} precert
   */
  exports.prototype['precert'] = undefined;
  /**
   * Indicates if this certificate is managed, i.e. provided by a third-party service that will also automatically renew the certificate when it becomes due. 
   * @member {Boolean} managed
   */
  exports.prototype['managed'] = undefined;
  /**
   * Indicates if this certificate belongs to the organisation, which means that it is served from one of the organization's properties. Do note that, in the case of certificate name mismatch, someone else's certificate may be considered as own. In that case, the **matchesOrgHost** field will be set to false. 
   * @member {module:model/Cert.OwnershipEnum} ownership
   */
  exports.prototype['ownership'] = undefined;
  /**
   * Indicates if at least one of the host listed in the certificates matches a hosts that belongs to the organisation. 
   * @member {Boolean} matchesOrgHost
   */
  exports.prototype['matchesOrgHost'] = undefined;
  /**
   * Indicates if this certificate was issued from Symantec's PKI infrastructure. 
   * @member {module:model/Cert.SymantecStatusEnum} symantecStatus
   */
  exports.prototype['symantecStatus'] = undefined;
  /**
   * Indicates whether certificate is required to be logged to CT for use on public sites. This is a requirement for all certificates issued from May 2018 onwards, as well for some earlier Symantec certificates. 
   * @member {Boolean} ctRequired
   */
  exports.prototype['ctRequired'] = undefined;
  /**
   * Indicates whether certificate embeds sufficient SCTs to satisfy CT compliance.
   * @member {Boolean} ctCompliant
   */
  exports.prototype['ctCompliant'] = undefined;
  /**
   * @member {Array.<module:model/CertCtLog>} ctLogs
   */
  exports.prototype['ctLogs'] = undefined;
  /**
   * Base64-encoded certificate in DER format
   * @member {String} pem
   */
  exports.prototype['pem'] = undefined;


  /**
   * Allowed values for the <code>sigAlg</code> property.
   * @enum {String}
   * @readonly
   */
  exports.SigAlgEnum = {
    /**
     * value: "RSAwithMD2"
     * @const
     */
    "RSAwithMD2": "RSAwithMD2",
    /**
     * value: "RSAwithMD5"
     * @const
     */
    "RSAwithMD5": "RSAwithMD5",
    /**
     * value: "RSAwithSHA1"
     * @const
     */
    "RSAwithSHA1": "RSAwithSHA1",
    /**
     * value: "RSAwithSHA256"
     * @const
     */
    "RSAwithSHA256": "RSAwithSHA256",
    /**
     * value: "RSAwithSHA384"
     * @const
     */
    "RSAwithSHA384": "RSAwithSHA384",
    /**
     * value: "RSAwithSHA512"
     * @const
     */
    "RSAwithSHA512": "RSAwithSHA512",
    /**
     * value: "RSAPSS"
     * @const
     */
    "RSAPSS": "RSAPSS",
    /**
     * value: "DSAwithSHA1"
     * @const
     */
    "DSAwithSHA1": "DSAwithSHA1",
    /**
     * value: "DSAwithSHA256"
     * @const
     */
    "DSAwithSHA256": "DSAwithSHA256",
    /**
     * value: "ECDSAwithSHA1"
     * @const
     */
    "ECDSAwithSHA1": "ECDSAwithSHA1",
    /**
     * value: "ECDSAwithSHA256"
     * @const
     */
    "ECDSAwithSHA256": "ECDSAwithSHA256",
    /**
     * value: "ECDSAwithSHA384"
     * @const
     */
    "ECDSAwithSHA384": "ECDSAwithSHA384",
    /**
     * value: "ECDSAwithSHA512"
     * @const
     */
    "ECDSAwithSHA512": "ECDSAwithSHA512"  };

  /**
   * Allowed values for the <code>ownership</code> property.
   * @enum {String}
   * @readonly
   */
  exports.OwnershipEnum = {
    /**
     * value: "own"
     * @const
     */
    "own": "own",
    /**
     * value: "thirdParty"
     * @const
     */
    "thirdParty": "thirdParty"  };

  /**
   * Allowed values for the <code>symantecStatus</code> property.
   * @enum {String}
   * @readonly
   */
  exports.SymantecStatusEnum = {
    /**
     * value: "notSymantec"
     * @const
     */
    "notSymantec": "notSymantec",
    /**
     * value: "phaseOneAffected"
     * @const
     */
    "phaseOneAffected": "phaseOneAffected",
    /**
     * value: "phaseOneNotAffected"
     * @const
     */
    "phaseOneNotAffected": "phaseOneNotAffected",
    /**
     * value: "phaseTwoAffected"
     * @const
     */
    "phaseTwoAffected": "phaseTwoAffected",
    /**
     * value: "phaseTwoNotAffected"
     * @const
     */
    "phaseTwoNotAffected": "phaseTwoNotAffected",
    /**
     * value: "symantecExcluded"
     * @const
     */
    "symantecExcluded": "symantecExcluded"  };


  return exports;
}));


